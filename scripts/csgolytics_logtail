#!/usr/bin/env ruby
$: << ::File::expand_path("../", __FILE__)

require "fileutils"
require 'optparse'
require 'uri'
require 'net/http'

POLL_INTERVAL = 1

# parse flags
@logdir = nil
@target_addr = nil

flag_parser = OptionParser.new do |opts|
  opts.banner = "Usage: csgolytics_logtail [options]"

  opts.on("--logdir=PATH", "/path/to/csgo/log") do |val|
    @logdir = val
  end

  opts.on("--target=ADDR", "http://localhost:3765") do |val|
    @target_addr = URI.parse(val)
  end

  opts.on("-h", "--help", "You're reading it") do
    puts opts
    exit 0
  end

end

flag_parser.parse!

def upload_logline(logline)
  request = Net::HTTP::Post.new("/api/v1/insert_logline")
  request.body = logline

  http = Net::HTTP.new(@target_addr.host, @target_addr.port)
  response = http.request(request)

  if response.code.to_i == 201
    raise "HTTP ERROR (#{response.code}): #{response.body[0..128]}"
  end
end

# tail the logfiles
loop do
  # list all logfiles
  @logfiles = {}
  @logfiles_completed = {}
  Dir.entries(@logdir).each do |f|
    if f.end_with?(".log")
      @logfiles[f] = true
    end

    if f =~ /^\.(.*\.log)\.csgolytics_complete$/
      @logfiles_completed[$1] = true
    end
  end

  @logfiles = (@logfiles.keys - @logfiles_completed.keys).sort

  # read each logfile from the last offset and upload new lines
  @logfiles.each_with_index do |fname, logfile_index|
    fpath = File.join(@logdir, fname)
    offset_file_path = File.join(@logdir, ".#{fname}.csgolytics_offset")
    offset = 0
    if File.exists?(offset_file_path)
      offset = IO.read(offset_file_path).to_i
    end

    puts "Reading #{fpath} from #{offset}"

    f = File.open(fpath)
    f.seek(offset)
    while l = (f.readline rescue nil)
      upload_logline(l.chomp)
      File.write(offset_file_path + "~", f.tell)
      FileUtils.mv(offset_file_path + "~", offset_file_path)
    end

    if logfile_index < @logfiles.length - 1
      FileUtils.touch(File.join(@logdir, ".#{fname}.csgolytics_complete"))
    end
  end

  sleep POLL_INTERVAL
end
